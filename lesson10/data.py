questions = {
    "ЛЕГКИЙ": [
        {
            "quest": "Какой оператор используется для возведения в степень в Python?",
            "answers": ["^", "**", "^^", "pow()"],
            "right": "**"
        },
        {
            "quest": "Как получить длину списка в Python?",
            "answers": ["list.size()", "list.length()", "len(list)", "list.count()"],
            "right": "len(list)"
        },
        {
            "quest": "Что выведет: print(type(5))?",
            "answers": ["<class 'int'>", "<class 'float'>", "<class 'number'>", "Ошибка"],
            "right": "<class 'int'>"
        },
        {
            "quest": "Какой символ используется для однострочных комментариев?",
            "answers": ["//", "#", "/*", "--"],
            "right": "#"
        },
        {
            "quest": "Как создать пустой список?",
            "answers": ["list()", "[]", "list[]", "Оба варианта верны"],
            "right": "Оба варианта верны"
        }
    ],
    
    "СРЕДНИЙ": [
        {
            "quest": "Что такое list comprehension?",
            "answers": ["Ошибка в списке", "Способ создания списка в одну строку", "Метод сортировки списка", "Тип данных"],
            "right": "Способ создания списка в одну строку"
        },
        {
            "quest": "Чем отличается список от кортежа?",
            "answers": ["Ничем", "Список изменяемый, кортеж - нет", "Кортеж быстрее", "Список может содержать только числа"],
            "right": "Список изменяемый, кортеж - нет"
        },
        {
            "quest": "Что такое *args и **kwargs?",
            "answers": ["Специальные переменные для циклов", "Аргументы для передачи произвольного количества позиционных и именованных аргументов", "Модули для работы с аргументами", "Синтаксис для умножения"],
            "right": "Аргументы для передачи произвольного количества позиционных и именованных аргументов"
        },
        {
            "quest": "Что такое декоратор?",
            "answers": ["Функция, изменяющая поведение другой функции", "Специальный синтаксис для классов", "Модуль для оформления кода", "Тип данных"],
            "right": "Функция, изменяющая поведение другой функции"
        },
        {
            "quest": "Как работает оператор 'is' в отличие от '=='?",
            "answers": ["'is' сравнивает идентичность объектов, '==' - значения", "'is' для чисел, '==' для строк", "Это одно и то же", "'is' быстрее"],
            "right": "'is' сравнивает идентичность объектов, '==' - значения"
        }
    ],
    
    "СЛОЖНЫЙ": [
        {
            "quest": "Что такое GIL (Global Interpreter Lock) в Python?",
            "answers": ["Механизм синхронизации потоков, позволяющий выполнять только один поток за раз", "Глобальная блокировка для ускорения выполнения", "Модуль для работы с графикой", "Оптимизация памяти"],
            "right": "Механизм синхронизации потоков, позволяющий выполнять только один поток за раз"
        },
        {
            "quest": "Что такое MRO (Method Resolution Order)?",
            "answers": ["Алгоритм сортировки методов при множественном наследовании", "Модуль для работы с регулярными выражениями", "Метод разрешения объектов в памяти", "Оптимизация выполнения кода"],
            "right": "Алгоритм сортировки методов при множественном наследовании"
        },
        {
            "quest": "Что такое дескрипторы (descriptors) в Python?",
            "answers": ["Специальные объекты, реализующие протокол __get__, __set__, __delete__", "Методы для описания классов", "Декораторы для функций", "Аннотации типов"],
            "right": "Специальные объекты, реализующие протокол __get__, __set__, __delete__"
        },
        {
            "quest": "Что такое metaclass и когда её использовать?",
            "answers": ["Класс, экземпляры которого являются классами, используется для создания API, ORM", "Класс для метапрограммирования, всегда лучше избегать", "Родительский класс для всех классов", "Специальный декоратор для классов"],
            "right": "Класс, экземпляры которого являются классами, используется для создания API, ORM"
        },
        {
            "quest": "Как работает механизм кэширования int'ов в Python (-5 до 256)?",
            "answers": ["Интернирование (interning) часто используемых целых чисел", "Компиляторная оптимизация", "Кэширование в bytecode", "Особенность реализации CPython"],
            "right": "Интернирование (interning) часто используемых целых чисел"
        }
    ],
    
    "ХАРДКОР ДЛЯ ДМИТРИЯ": [
        {
            "quest": "Как работает C3 linearization в MRO?",
            "answers": ["Алгоритм, гарантирующий монотонность и предотвращающий неоднозначности при множественном наследовании", "Линейная оптимизация кода", "Способ компиляции Python", "Метод кэширования"],
            "right": "Алгоритм, гарантирующий монотонность и предотвращающий неоднозначности при множественном наследовании"
        },
        {
            "quest": "Как работает garbage collection для цикличных ссылок?",
            "answers": ["Использует алгоритм подсчета ссылок + generational GC с mark-and-sweep", "Удаляет все объекты раз в час", "Не удаляет цикличные ссылки вообще", "Использует только reference counting"],
            "right": "Использует алгоритм подсчета ссылок + generational GC с mark-and-sweep"
        },
        {
            "quest": "Как работает механизм импорта модулей на уровне sys.meta_path?",
            "answers": ["Использует finders и loaders из meta_path для поиска и загрузки модулей", "Ищет модули только в sys.path", "Компилирует все модули при запуске", "Использует кэширование через .pyc файлы"],
            "right": "Использует finders и loaders из meta_path для поиска и загрузки модулей"
        },
        {
            "quest": "Что такое coroutine и как она отличается от generator?",
            "answers": ["Coroutine может принимать данные через .send(), generator только yield'ит, а также имеет дополнительные методы .throw() и .close()", "Это одно и то же", "Coroutine использует async/await, generator — yield", "Generator является подвидом coroutine"],
            "right": "Coroutine может принимать данные через .send(), generator только yield'ит, а также имеет дополнительные методы .throw() и .close()"
        },
        {
            "quest": "Как работает механизм декораторов с аргументами (@decorator(arg))?",
            "answers": ["Создается функция-фабрика, которая принимает аргументы и возвращает декоратор", "Это синтаксическая ошибка", "Аргументы передаются напрямую в декорируемую функцию", "Использует магию __call__"],
            "right": "Создается функция-фабрика, которая принимает аргументы и возвращает декоратор"
        }
    ]
}


