questions = {
    "ЛЕГКИЙ": [
        {
            "quest": "Какой оператор используется для возведения в степень в Python?",
            "answers": ["^", "**", "^^", "pow()"],
            "right": "**"  
        },
        {
            "quest": "Как получить длину списка в Python?",
            "answers": ["len(list)", "list.size()", "list.length()", "list.count()"],
            "right": "len(list)"  
        },
        {
            "quest": "Что выведет: print(type(5))?",
            "answers": ["<class 'float'>", "<class 'int'>", "<class 'number'>", "Ошибка"],
            "right": "<class 'int'>"  
        },
        {
            "quest": "Какой символ используется для однострочных комментариев?",
            "answers": ["#", "//", "/*", "--"],
            "right": "#"  
        },
        {
            "quest": "Как создать пустой список?",
            "answers": ["list()", "[]", "Оба варианта верны", "list[]"],
            "right": "Оба варианта верны"  
        }
    ],
    
    "СРЕДНИЙ": [
        {
            "quest": "Что такое list comprehension?",
            "answers": ["Способ создания списка в одну строку", "Ошибка в списке", "Метод сортировки списка", "Тип данных"],
            "right": "Способ создания списка в одну строку" 
        },
        {
            "quest": "Чем отличается список от кортежа?",
            "answers": ["Кортеж быстрее", "Список изменяемый, кортеж - нет", "Ничем", "Список может содержать только числа"],
            "right": "Список изменяемый, кортеж - нет"  
        },
        {
            "quest": "Что такое *args и **kwargs?",
            "answers": ["Синтаксис для умножения", "Аргументы для передачи произвольного количества позиционных и именованных аргументов", "Специальные переменные для циклов", "Модули для работы с аргументами"],
            "right": "Аргументы для передачи произвольного количества позиционных и именованных аргументов"  
        },
        {
            "quest": "Что такое декоратор?",
            "answers": ["Модуль для оформления кода", "Функция, изменяющая поведение другой функции", "Специальный синтаксис для классов", "Тип данных"],
            "right": "Функция, изменяющая поведение другой функции"  
        },
        {
            "quest": "Как работает оператор 'is' в отличие от '=='?",
            "answers": ["Это одно и то же", "'is' быстрее", "'is' сравнивает идентичность объектов, '==' - значения", "'is' для чисел, '==' для строк"],
            "right": "'is' сравнивает идентичность объектов, '==' - значения"  
        }
    ],
    
    "СЛОЖНЫЙ": [
        {
            "quest": "Что такое GIL (Global Interpreter Lock) в Python?",
            "answers": ["Глобальная блокировка для ускорения выполнения", "Оптимизация памяти", "Механизм синхронизации потоков, позволяющий выполнять только один поток за раз", "Модуль для работы с графикой"],
            "right": "Механизм синхронизации потоков, позволяющий выполнять только один поток за раз"  
        },
        {
            "quest": "Что такое MRO (Method Resolution Order)?",
            "answers": ["Метод разрешения объектов в памяти", "Алгоритм сортировки методов при множественном наследовании", "Модуль для работы с регулярными выражениями", "Оптимизация выполнения кода"],
            "right": "Алгоритм сортировки методов при множественном наследовании"  
        },
        {
            "quest": "Что такое дескрипторы (descriptors) в Python?",
            "answers": ["Методы для описания классов", "Специальные объекты, реализующие протокол __get__, __set__, __delete__", "Декораторы для функций", "Аннотации типов"],
            "right": "Специальные объекты, реализующие протокол __get__, __set__, __delete__"  
        },
        {
            "quest": "Что такое metaclass и когда её использовать?",
            "answers": ["Специальный декоратор для классов", "Класс для метапрограммирования, всегда лучше избегать", "Класс, экземпляры которого являются классами, используется для создания API, ORM", "Родительский класс для всех классов"],
            "right": "Класс, экземпляры которого являются классами, используется для создания API, ORM"  
        },
        {
            "quest": "Как работает механизм кэширования int'ов в Python (-5 до 256)?",
            "answers": ["Кэширование в bytecode", "Интернирование (interning) часто используемых целых чисел", "Особенность реализации CPython", "Компиляторная оптимизация"],
            "right": "Интернирование (interning) часто используемых целых чисел"  
        }
    ],
    
    "ХАРДКОР ДЛЯ ДМИТРИЯ": [
        {
            "quest": "Как работает C3 linearization в MRO?",
            "answers": ["Линейная оптимизация кода", "Алгоритм, гарантирующий монотонность и предотвращающий неоднозначности при множественном наследовании", "Способ компиляции Python", "Метод кэширования"],
            "right": "Алгоритм, гарантирующий монотонность и предотвращающий неоднозначности при множественном наследовании"  
        },
        {
            "quest": "Как работает garbage collection для цикличных ссылок?",
            "answers": ["Удаляет все объекты раз в час", "Использует только reference counting", "Использует алгоритм подсчета ссылок + generational GC с mark-and-sweep", "Не удаляет цикличные ссылки вообще"],
            "right": "Использует алгоритм подсчета ссылок + generational GC с mark-and-sweep"  
        },
        {
            "quest": "Как работает механизм импорта модулей на уровне sys.meta_path?",
            "answers": ["Компилирует все модули при запуске", "Использует кэширование через .pyc файлы", "Ищет модули только в sys.path", "Использует finders и loaders из meta_path для поиска и загрузки модулей"],
            "right": "Использует finders и loaders из meta_path для поиска и загрузки модулей"  
        },
        {
            "quest": "Что такое coroutine и как она отличается от generator?",
            "answers": ["Generator является подвидом coroutine", "Coroutine может принимать данные через .send(), generator только yield'ит, а также имеет дополнительные методы .throw() и .close()", "Это одно и то же", "Coroutine использует async/await, generator — yield"],
            "right": "Coroutine может принимать данные через .send(), generator только yield'ит, а также имеет дополнительные методы .throw() и .close()"  
        },
        {
            "quest": "Как работает механизм декораторов с аргументами (@decorator(arg))?",
            "answers": ["Создается функция-фабрика, которая принимает аргументы и возвращает декоратор", "Аргументы передаются напрямую в декорируемую функцию", "Использует магию __call__", "Это синтаксическая ошибка"],
            "right": "Создается функция-фабрика, которая принимает аргументы и возвращает декоратор" 
        }
    ]
}